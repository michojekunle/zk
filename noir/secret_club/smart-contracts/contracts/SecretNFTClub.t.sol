// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {SecretNFTClub} from "./SecretNFTClub.sol";
import {HonkVerifier} from "./Verifier.sol";

/**
 * @title SecretNFTClubTest
 * @notice Simple test suite for SecretNFTClub with real Honk verifier
 * @dev These tests use the actual UltraHonk verifier generated by Noir
 */
contract SecretNFTClubTest is Test {
    SecretNFTClub public club;
    HonkVerifier public verifier;

    // Test accounts
    address public alice;
    address public bob;

    // Secret hash (computed from your Noir circuit)
    bytes32 public constant SECRET_HASH =
        0x297fad8a9bc7f877e7ae8ab582a32a16ec2d11cc57cd77ecab97d2c775fa29e8;

    event MemberJoined(address indexed member, uint256 indexed tokenId);

    function setUp() public {
        alice = makeAddr("alice");
        bob = makeAddr("bob");

        verifier = new HonkVerifier();
        club = new SecretNFTClub(SECRET_HASH, address(verifier));
    }

    /*//////////////////////////////////////////////////////////////
                        DEPLOYMENT TESTS
    //////////////////////////////////////////////////////////////*/

    function test_Deployment_SetsSecretHash() public view {
        assertEq(club.secretHash(), SECRET_HASH);
    }

    function test_Deployment_SetsVerifier() public view {
        assertEq(address(club.verifier()), address(verifier));
    }

    function test_Deployment_InitialMemberCountIsZero() public view {
        assertEq(club.totalMembers(), 0);
    }

    /*//////////////////////////////////////////////////////////////
                        VIEW FUNCTION TESTS
    //////////////////////////////////////////////////////////////*/

    function test_IsMember_ReturnsFalseForNewAddress() public view {
        assertFalse(club.isMember(alice));
    }

    function test_HasJoined_ReturnsFalseForNewAddress() public view {
        assertFalse(club.hasJoined(alice));
    }

    function test_TotalMembers_ReturnsZeroInitially() public view {
        assertEq(club.totalMembers(), 0);
    }

    function test_MemberTokenId_ReturnsZeroForNonMember() public view {
        assertEq(club.memberTokenId(alice), 0);
    }

    /*//////////////////////////////////////////////////////////////
                        JOIN FUNCTION TESTS
    //////////////////////////////////////////////////////////////*/

    function test_Join_RevertsWithEmptyProof() public {
        bytes memory emptyProof = "";

        vm.prank(alice);
        vm.expectRevert();
        club.join(emptyProof);
    }

    function test_Join_RevertsWithInvalidProof() public {
        // Create a properly sized but invalid proof (proofs are ~14KB for UltraHonk)
        bytes memory invalidProof = new bytes(14080); // Proper size but all zeros

        vm.prank(alice);
        vm.expectRevert();
        club.join(invalidProof);
    }

    function test_Join_RevertsWithWrongProofSize() public {
        // Too small proof should fail
        bytes memory tooSmallProof = hex"1234567890abcdef";

        vm.prank(alice);
        vm.expectRevert(); // Will revert in verifier with wrong size
        club.join(tooSmallProof);
    }

      /*//////////////////////////////////////////////////////////////
                    VALID PROOF TESTS (INTEGRATION)
    //////////////////////////////////////////////////////////////*/
    
    /**
     * @notice Test successful join with valid proof
     * @dev To generate a valid proof:
     * 1. In your Noir circuit directory, create Prover.toml:
     *    secret = "0x<your-secret-field>"
     *    public_hash = "0x2a5c8d9e7f3b4a1c6e8d9f2a5b7c3e4d1f9a8b7c6e5d4a3b2c1e9f8d7c6b5a4"
     * 2. Run: nargo prove
     * 3. The proof will be in target/secret_club.proof
     * 4. Convert to hex and paste below
     */
    function test_Join_SucceedsWithValidProof() public {
        // PASTE YOUR GENERATED PROOF HERE
        // Example format:
        // bytes memory validProof = hex"<your-proof-hex>";
        
        // Uncomment when you have a real proof:
        /*
        vm.prank(alice);
        
        // Should emit event
        vm.expectEmit(true, true, false, false);
        emit MemberJoined(alice, 0);
        
        club.join(validProof);
        
        // Verify state changes
        assertTrue(club.isMember(alice));
        assertTrue(club.hasJoined(alice));
        assertEq(club.memberTokenId(alice), 0);
        assertEq(club.totalMembers(), 1);
        */
        
        // Skip test for now
        vm.skip(true);
    }
    
    /**
     * @notice Test multiple users joining with valid proofs
     */
    function test_Join_MultipleUsersCanJoin() public {
        // You'll need to generate separate proofs for different users
        // Each proof proves knowledge of the same secret
        
        // Uncomment when you have real proofs:
        /*
        bytes memory aliceProof = hex"<alice-proof>";
        bytes memory bobProof = hex"<bob-proof>";
        
        // Alice joins
        vm.prank(alice);
        club.join(aliceProof);
        
        // Bob joins
        vm.prank(bob);
        club.join(bobProof);
        
        // Verify both are members
        assertTrue(club.isMember(alice));
        assertTrue(club.isMember(bob));
        assertEq(club.totalMembers(), 2);
        assertEq(club.memberTokenId(alice), 0);
        assertEq(club.memberTokenId(bob), 1);
        */
        
        vm.skip(true);
    }
    
    /**
     * @notice Test that same user cannot join twice
     */
    function test_Join_RevertsWhenJoiningTwice() public {
        // Uncomment when you have a real proof:
        /*
        bytes memory validProof = hex"<your-proof-hex>";
        
        // First join succeeds
        vm.prank(alice);
        club.join(validProof);
        
        // Second join should fail
        vm.prank(alice);
        vm.expectRevert(SecretNFTClub.AlreadyMember.selector);
        club.join(validProof);
        */
        
        vm.skip(true);
    }

    /*//////////////////////////////////////////////////////////////
                        SECURITY TESTS
    //////////////////////////////////////////////////////////////*/

    function test_Security_SecretHashIsPubliclyReadable() public view {
        bytes32 hash = club.secretHash();
        assertEq(hash, SECRET_HASH);
    }

    function test_Security_VerifierIsImmutable() public view {
        address verifierAddr = address(club.verifier());
        assertEq(verifierAddr, address(verifier));
    }

    /*//////////////////////////////////////////////////////////////
                        FUZZ TESTS
    //////////////////////////////////////////////////////////////*/

    function testFuzz_IsMember_AlwaysFalseForNewAddresses(
        address user
    ) public view {
        vm.assume(user != address(0));
        assertFalse(club.isMember(user));
    }

    function testFuzz_HasJoined_AlwaysFalseForNewAddresses(
        address user
    ) public view {
        vm.assume(user != address(0));
        assertFalse(club.hasJoined(user));
    }

    function testFuzz_Join_RevertsWithRandomProof(
        bytes memory randomProof
    ) public {
        vm.assume(randomProof.length > 0);
        vm.assume(randomProof.length < 10000);

        vm.prank(alice);
        vm.expectRevert();
        club.join(randomProof);
    }
}
